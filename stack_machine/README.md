## Стековая машина

### Память

Память процессора состоит из слов (4 байта).  
Она организована в виде массива `M` из `N` слов, ячеек памяти от `0` до `N-1`.  
Одно слово хранит или целое в дополнительном коде, или вещественное.  

#### Программа

При запуске машины программа длиной `P` слов загружается в память по адресам от `0` до `P - 1`.

#### Стек

Стек растёт от старших адресов к младшим.  

Push в стек: `M[--SP] = x`  
Pop из стека: `x = M[SP++]`

### Регистры

* `CP` - code pointer, содержит адрес инструкции, которая будет выполнена следующей
* `SP` - stack pointer, содержит адрес слова, хранящего адрес последнего элемента, добавленного в стек
* `BP` - base pointer, указатель базы, используется для организации стековых фреймов

При запуске машины `CP = 0`, `SP = N`, `BP = 0`.  

### Инструкции

Каждая инструкция занимает одно слово.  
Код операции воспринимаем в виде знакового целого.  

```
имя-команды (код операции) : ... стек до --> ... стек после
```

Все коды инструкций отрицательные. Если код операции неотрицателен, она просто кладёт его на стек.  

#### Работа с регистрами

* `GETSP (-27) : ...   --> ... SP`
* `SETSP (-28) : ... a --> ...    (SP := a)`
* `GETBP (-29) : ...   --> ... BP`
* `SETBP (-30) : ... a --> ...    (BP := a)`
* `GETCP (-31) : ...   --> ... CP`

#### Арифметические команды

`S` - знаковое целое (по умолчанию)  
`U` - беззнаковое целое  
`F` - вещественное  

* `ADD (-1) : ... x y --> ... x+y`  
  `FADD (-41)`, `UADD (-42)`  
* `SUB (-2) : ... x y --> ... x-y`  
  `FSUB (-43)`, `USUB (-44)`  
* `DIV (-3) : ... x y --> ... x/y`  
  `FDIV (-45)`, `UDIV (-46)`  
* `MOD (-4) : ... x y --> ... x%y`  
  `UMOD (-47)`  
* `MUL (-5) : ... x y --> ... x*y`  
  `FMUL (-48)`, `UMUL (-49)`  
* `NEG (-6) : ... x   --> ... -x`  
  `FNEG (-50)`  

<br>

* `BITAND (-7) : ... x y --> ... x&y`
* `BITOR  (-8) : ... x y --> ... x|y`
* `BITNOT (-9) : ... x   --> ... ~x`

#### Преобразование типов

* `S2F (-37) : ... x --> ... y`
* `F2S (-38) : ... x --> ... y`
* `U2F (-39) : ... x --> ... y`
* `F2U (-40) : ... x --> ... y`

#### Операции со стеком

* `DUP (-10)   : ... x         --> ... x x`
* `DROP (-11)  : ... x         --> ...`
* `SWAP (-12)  : ... x y       --> ... y x`
* `ROT (-13)   : ... x y z     --> ... y z x`
* `OVER (-14)  : ... x y       --> ... x y x`
* `DROPN (-35) : ... x1...xN N --> ...         (SP += N + 1)`
* `PUSHN (-36) : ... N         --> ... x1...xN (SP -= N - 1)`

#### Операции работы с памятью

* `READ (-15)  : ... a   --> ... M[a]`
* `WRITE (-16) : ... a v --> ...      (M[a] := v)`

#### Операции управления

* `CMP (-17)  : ... x y --> ... sgn`  
  `FCMP (-51)`, `UCMP (-52)`  

  `sgn = -1`, если `x < y`  
  `sgn = 0`, если `x = y`  
  `sgn = 1`, если `x > y`  

* `JMP (-18)  : ... a   --> ...          (CP := a)`
* `JLT (-19)  : ... x a --> ...          (CP := x < 0 ? a : CP+1)`
* `JGT (-20)  : ... x a --> ...          (CP := x > 0 ? a : CP+1)`
* `JEQ (-21)  : ... x a --> ...          (CP := x = 0 ? a : CP+1)`
* `JLE (-22)  : ... x a --> ...          (CP := x <= 0 ? a : CP+1)`
* `JGE (-23)  : ... x a --> ...          (CP := x >= 0 ? a : CP+1)`
* `JNE (-24)  : ... x a --> ...          (CP := x != 0 ? a : CP+1)`
* `CALL (-25) : ... a   --> ... CP+1     (CP := a)`
* `RETN (-26) : ... x1...xN a N --> ...  (CP := a)`
* `HALT (-32) : ... x   --> ...`

<br>

* `FJLT`, `UJLT`, `FJGT`, `UJGT`, ... ?

#### Ввод-вывод (Unicode)

* `IN (-33)  : ...   --> ... c`
* `OUT (-34) : ... c --> ...`

## Синтаксис языка ассемблера

Комментарии начинаются со знака `;` и продолжаются до конца строки.  

```
Программа := { Инструкция | ОпределениеКонстанты }

Инструкция = Слагаемое
Слагаемое = ЧИСЛО | ИМЯ | "(" Выражение ")" | "@"
Выражение = ["-"] Слагаемое { ("+" | "-") Слагаемое }

ОпределениеКонстанты = ":" ИМЯ ["=" Слагаемое]

ЧИСЛО = ["+"|"-"] ЦИФРА { ЦИФРА }
ЦИФРА = "0" | "1" | ... | "9"

ИМЯ = БУКВА { БУКВА | ЦИФРА }.
БУКВА = "A" | ... | "Z" | "a" | ... | "z" | "_"
```

`@` - количество ранее скомпилированных инструкций.
